<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Разработка on Sharing knowledge</title>
    <link>https://uthark.github.io/categories/%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0/</link>
    <description>Recent content in Разработка on Sharing knowledge</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Apr 2012 15:03:00 +0000</lastBuildDate>
    
	<atom:link href="https://uthark.github.io/categories/%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Собственная реализация методов в Spring Data JPA</title>
      <link>https://uthark.github.io/2012/04/28/spring-data-jpa_28/</link>
      <pubDate>Sat, 28 Apr 2012 15:03:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/28/spring-data-jpa_28/</guid>
      <description>Очевидно, что мы не всегда можем воспользоваться автоматической генерацией кода, предоставляемой Spring Data JPA. Например, у нас слишком сложный запрос, или нам необходимо вызвать процедуру в базе данных, либо у нас сложная бизнес-логика.
Рассмотрим следующий пример - например, нам нужна функциональность уникального счётчика, который мы решили реализовать с помощью последовательности (sequence).
Сначала определим интерфейс, в котором опишем все методы, которые мы будем реализовывать самостоятельно. В нашем случае, это будет только один метод:</description>
    </item>
    
    <item>
      <title>Использование BeanPostProcessor на примере журналирования</title>
      <link>https://uthark.github.io/2012/04/20/beanpostprocessor/</link>
      <pubDate>Fri, 20 Apr 2012 15:51:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/20/beanpostprocessor/</guid>
      <description>Сегодня я хочу рассказать, как можно сделать инициализацию логгера в классе с использованием аннотаций и BeanPostProcessor
Очень часто мы инициализируем логгер следующим образом:
public class MyClass { private static final Logger LOG = LoggerFactory.getLogger(MyClass.class); } Я покажу, как сделать, чтобы можно было писать вот так:
@Log private Logger LOG; Первым делом нам нужно объявить аннотацию:
@Retention(RUNTIME) @Target(FIELD) @Documented public @interface Log { String category() default &amp;#34;&amp;#34;; } А вторым делом, написать собственный BeanPostProcessor, который бы устанавливал нам логгер:</description>
    </item>
    
    <item>
      <title>Преобразуем строку в дату</title>
      <link>https://uthark.github.io/2012/04/20/blog-post/</link>
      <pubDate>Fri, 20 Apr 2012 15:25:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/20/blog-post/</guid>
      <description>Казалось бы, есть простейшая задача - преобразовать строковое представление даты в объект класса java.util.Date.
Как оказалось, иногда использование DateFormat не помогает. В случае, если строка - это заголовок Date из письма, то нам нужно использовать javax.mail.internet.MailDateFormat для преобразования такой строки.
String dateStr = ... Date parsedDate = new MailDateFormat().</description>
    </item>
    
    <item>
      <title>Упрощаем работу с JPA при помощи Spring Data JPA</title>
      <link>https://uthark.github.io/2012/02/23/jpa-spring-data-jpa/</link>
      <pubDate>Thu, 23 Feb 2012 02:17:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/02/23/jpa-spring-data-jpa/</guid>
      <description>Введение Уже прошло несколько лет с тех пор, как появился JPA. Работа с EntityManager увлекательна, но разработчики пишут красивый API, а подробности работы с базой данных скрывают. При этом частая проблема - дублирование имплементации, когда из одного DAO в другой у нас плавно перекочёвывает один и тот же код, в лучшем случае этот код переносится в абстрактный базовый DAO. Spring Data коренным образом решает проблему - при его использовании остаётся только API на уровне интерфейсов, вся имплементация создаётся автоматически с использованием AOP.</description>
    </item>
    
    <item>
      <title>Разработка и тестирование Java REST веб-сервисов</title>
      <link>https://uthark.github.io/2012/02/09/java-rest/</link>
      <pubDate>Thu, 09 Feb 2012 01:05:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/02/09/java-rest/</guid>
      <description>Введение Для разработки REST веб-сервисов Java предлагает JSR-311 - JAX-RS: The Java&amp;trade; API for RESTful Web Services Как это обычно бывает в мире Enterprise Java, существует несколько реализаций данной спецификации:  Jersey - это эталонная реализация спецификации от компании Sun Oracle Apache CXF JBoss RESTEasy  На примере последней реализации, я и расскажу, каким образом можно написать REST-сервис. Пишем REST-сервис import javax.ws.rs.*; import javax.ws.rs.core.MediaType; @Path(&amp;#34;/service/entity&amp;#34;) @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public interface EntityRestService { @GET @Path(&amp;#34;/all&amp;#34;) EntityList listAll(); @GET @Path(&amp;#34;/{id}&amp;#34;) Entity findById(@PathParam(&amp;#34;id&amp;#34;) Integer id); } Создаём интерфейс, в котором расставляем JAX-RS аннотации.</description>
    </item>
    
    <item>
      <title>Немножко магии от AspectJ</title>
      <link>https://uthark.github.io/2012/01/28/aspectj/</link>
      <pubDate>Sat, 28 Jan 2012 02:43:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/01/28/aspectj/</guid>
      <description>Наверно, вы уже сталкивались с таким понятием, как AOП - аспектно-ориентированное программирование.
Обычно, про него вспоминают, когда говорят про декларативное использование транзакций, про проверку прав доступа, либо про реализацию журналирования.
Но это не единственные области применения АОП.
Я хочу показать ещё пару областей применения из реальных проектов:
1. Модификация исходного кода для реализации дополнительных возможностей.
2. Принудительная проверка контракта между модулями.
Модификация исходного кода для реализации дополнительных возможностейПредположим, что у нас есть модуль в приложении, который предоставляет нужную нам функциональность.</description>
    </item>
    
    <item>
      <title>Сокращаем ссылки на андроиде</title>
      <link>https://uthark.github.io/2010/12/06/blog-post/</link>
      <pubDate>Mon, 06 Dec 2010 23:11:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/12/06/blog-post/</guid>
      <description>ВступлениеВстала передо мной задача - сокращать ссылки перед тем, как отправлять их в Twitter. Для решения этой задачи я решил использовать bit.ly, благо, их API внятный и простой. Программируем!Решение нарисовалось в виде следующего класса: import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.NameValuePair; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.utils.URIUtils; import org.apache.http.client.utils.URLEncodedUtils; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import org.json.JSONException; import org.json.JSONObject; import android.util.Log; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.util.ArrayList; import java.util.List; /** * Helper class to work with bitly.</description>
    </item>
    
    <item>
      <title>Удаление различных диакритических символов из строки</title>
      <link>https://uthark.github.io/2010/05/22/blog-post/</link>
      <pubDate>Sat, 22 May 2010 00:52:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/05/22/blog-post/</guid>
      <description>Возникла проблема - каким образом заменить в строке символы из национальных кодировок на соответствующие им из латиницы.
Например, из строки explicación получить explicacion.
package com.blogspot.atamanenko; import java.text.Normalizer; import java.text.Normalizer.Form; public class StringNormalizer { public static String normalize(String string) { return Normalizer.normalize(string, Form.NFD) .replaceAll(&amp;#34;\\p{InCombiningDiacriticalMarks}+&amp;#34;, &amp;#34;&amp;#34;); } } Вызов Normalizer.normalize проводит нормализацию входной строки. Последующий вызов регулярного выражения удаляет все диакритические знаки, полученные после нормализации.</description>
    </item>
    
    <item>
      <title>Несколько слов о GORM</title>
      <link>https://uthark.github.io/2010/04/11/gorm/</link>
      <pubDate>Sun, 11 Apr 2010 11:45:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/04/11/gorm/</guid>
      <description>В данной заметке хочу поделиться некоторыми моментами использования GORM.
GORM - это ORM-фреймворк, используемый в Grails. Реализован он поверх Hibernate, но, при этом, с некоторыми отличными умолчаниями.
Для разработчиков, знающих Hibernate, рекомендую тщательно изучить GORM, так как его поведение в некоторых случаях отлично от Hibernate, что может приводить к различным сюрпризам.
 Маппинг один-ко-многим По умолчанию GORM для связей один ко многим (one-to-many) создаёт таблицу-связку, которая обычно нужна только при связях между сущностями вида многие ко многим.</description>
    </item>
    
    <item>
      <title>Общение со Skype через D-Bus на Python</title>
      <link>https://uthark.github.io/2010/03/22/skype-d-bus-python/</link>
      <pubDate>Mon, 22 Mar 2010 23:50:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/03/22/skype-d-bus-python/</guid>
      <description>Summary: в данной заметке описывается работа с программой Skype через D-Bus на Python.
Введение Захотелось мне странного - когда я ухожу домой, мне нужно выключить amarok, kopete и Skype. Собственно, решено было через D-Bus отправлять вышеперечисленным приложениям релевантные сообщения.
Используем dbus-send Сначала я использовал обычный dbus-send, что оформилось в виде следующего скрипта go2home:
#!/bin/sh  # Stop amarok dbus-send --session --type=method_call --dest=org.kde.amarok /Player org.freedesktop.MediaPlayer.Stop # Logout from kopete dbus-send --session --type=method_call --dest=org.</description>
    </item>
    
    <item>
      <title>Разработка макроса для TiddlyWiki</title>
      <link>https://uthark.github.io/2010/03/21/tiddlywiki/</link>
      <pubDate>Sun, 21 Mar 2010 20:54:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/03/21/tiddlywiki/</guid>
      <description>Summary: Пример разработки плагина для TiddlyWiki
Вступление TiddlyWiki - это вики-движок, полностью написанный на JavaScript и хранящийся в одном файле (как сам движок, так и содержимое). Создатели позиционируют его как &amp;quot;переиспользуемую нелинейную персональную веб записную книжку&amp;quot;.
Я давно использую TiddlyWiki в различных целях:
По прямому назначению. Как систему GTD. Как домашнюю страницу на компьютере.  Моя домашняя страница на компьютере - это, если говорить терминами TiddlyWiki, тиддлер, содержащий ссылки на страницы, которые я часто посещаю.</description>
    </item>
    
    <item>
      <title>Вложенные транзакции в базах данных</title>
      <link>https://uthark.github.io/2010/02/05/blog-post/</link>
      <pubDate>Fri, 05 Feb 2010 01:20:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/02/05/blog-post/</guid>
      <description>Summary: Некоторые особенности вложенных транзакций.
Иногда бывает так, что при обработке запроса необходимо открыть ещё одну транзакцию в рамках текущей транзакции. Это называется вложенной транзакцией. Очень многие базы данных не поддерживают вложенные транзакции вообще, например, MySQL и Oracle. А те, что поддерживают, делают это на минимальном уровне, например, Sybase поддерживает только псевдовложенные транзакции.
Вложенные транзакции могут быть следующих видов:
Псевдо-вложенные транзакции Вложенная субтранзакция Вложенная независимая транзакция 
Псевдовложенные транзакции
Этот тип транзакций поддерживается базой данных Sybase.</description>
    </item>
    
    <item>
      <title>Двунаправленная ссылочная целостность</title>
      <link>https://uthark.github.io/2009/07/07/blog-post/</link>
      <pubDate>Tue, 07 Jul 2009 22:11:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/07/07/blog-post/</guid>
      <description>Здравствуйте.
Я считаю, что разработчику всегда стоит иметь представление о том, как работают низлежащие абстракции. Хотя бы потому, что часто абстракции бывают протекающими.
А веду я это к тому, что когда фреймворк вываливает стектрейс с несколькими вложенными (и, часто, для непосвященных непонятными) исключениями, то бывает непонятно, что с этим делать, особенно, если не знаешь, как реализована абстракция.
Иногда бывает нужно хранить двунаправленные связи между таблицами. Например, есть игрок и есть его статистика и нужно, чтобы каждая из сущностей знала про другую.</description>
    </item>
    
    <item>
      <title>Spring Roo (часть 2)</title>
      <link>https://uthark.github.io/2009/06/06/spring-roo-2/</link>
      <pubDate>Sat, 06 Jun 2009 22:19:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/06/06/spring-roo-2/</guid>
      <description>Архитектура сгенерированного приложения Spring Roo активно использует аспекты. В качестве реализации аспектов была взята библиотека aspectj. Большая часть сгенерированного кода попадает в отдельные файлы-аспекты. Создадим простой класс:
new persistent class jpa -name ~.domain.Action -testAutomatically add field string name -notNull -sizeMin 1 -sizeMax 80 add field string description -sizeMax 1024 Spring Roo создаст нам следующие файлы:
 Action.java Класс содержит только полезную с точки зрения назначения класса информацию. По сути, то, что вводит разработчик в консоль Roo аккумулируется здесь.</description>
    </item>
    
    <item>
      <title>Введение в Spring Roo</title>
      <link>https://uthark.github.io/2009/06/03/spring-roo/</link>
      <pubDate>Wed, 03 Jun 2009 00:06:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/06/03/spring-roo/</guid>
      <description>Недавно компания Spring Source презентовала новый продукт - Spring Roo. Цель проекта - повысить продуктивность Java-разработчиков. Почитав обзоры, а также потрогав его руками можно сделать вывод о том, что это, в некотором виде, альтернатива AppFuse и Grails.
Описание Spring Roo100% программирование на Java, предлагающее разработчикам известную, развитую и популярную платформу разработки.Прозрачные, надёжные и продуктивные сервисы среды разработки, такие как помощник кода, отладчики, визуальные отчёты об ошибка и т.д.Экстремально эффективная производительность во время выполнения, безопасность типов и отсутствие зависимостей на Roo во время выполнения.</description>
    </item>
    
    <item>
      <title>Сферический программист в вакууме и абстрактное понятие качества кода в условиях Fixed-Price проектов (часть 2)</title>
      <link>https://uthark.github.io/2009/05/27/fixed-price-2/</link>
      <pubDate>Wed, 27 May 2009 01:26:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/05/27/fixed-price-2/</guid>
      <description>Причин для написания плохого кода может быть несколько. Некоторые из них лежат на поверхности:
 Отсутствие опытаНевнимательность Некомпетентность Немотивированность Отсутствие опыта - казалось бы, самая простая причина проблемы; решение проблемы выглядит очевидным - со временем, разработчик будет писать код лучше. Но это ошибочное мнение. Бывает, люди с опытом более 5-10 лет разработки коммерческих приложений пишут настолько плохой код, что иногда кажется, что они это нарочно. Решать эту проблему необходимо постоянным указанием на ошибки.</description>
    </item>
    
    <item>
      <title>Сферический программист в вакууме и абстрактное понятие качества кода в условиях Fixed-Price проектов (часть 1)</title>
      <link>https://uthark.github.io/2009/05/27/fixed-price-1/</link>
      <pubDate>Wed, 27 May 2009 00:36:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/05/27/fixed-price-1/</guid>
      <description>В последнее время всё чаще задумываюсь о том, почему разработчики пишут плохой и некачественный код. Под кодом я подразумеваю не только сам код, но и, в том числе, архитектуру и дизайн.
Плохим кодом я считаю следущий: Невыполняющий функциональные требованияНевыполняющий нефункциональные требованияНепокрытый тестамиПлохо тестируемыйПлохо поддерживаемыйС багамиНеоптимальныйЕсли код не выполняет функциональные требования, то этот код вообще ничего не стоит. Заказчику такой код не нужен, именно поэтому этот код плохой. На него были потрачены ресурсы, но при этом сам код не имеет никакой ценности.</description>
    </item>
    
    <item>
      <title>Транзакции в реляционных базах данных</title>
      <link>https://uthark.github.io/2009/04/24/blog-post_24/</link>
      <pubDate>Fri, 24 Apr 2009 21:49:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/04/24/blog-post_24/</guid>
      <description>При работе в многопользовательском окружении может возникнуть ситуация, когда разные пользователи или системы обновляют одни и те же данные. Это может привести к ситуации, когда один из пользователей изменит данные, которые уже изменял другой пользователь и приведёт либо к потере данных, либо к переводу данных в неконсистентное состояние. Для решения этой проблемы были придуманы транзакции. Целью транзакции является создание абстракции того, что каждый пользователь - единственный в системе.
Характеристики транзакций В конце 1970-х Джим Грей выделил следующие характеристики транзакций:</description>
    </item>
    
    <item>
      <title>Кратко о блокировках в БД</title>
      <link>https://uthark.github.io/2009/04/22/blog-post_22/</link>
      <pubDate>Wed, 22 Apr 2009 23:58:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/04/22/blog-post_22/</guid>
      <description>Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.
Существует два вида блокировок - оптимистичная и пессимистичная.
Оптимистичная блокировка При оптимистичной блокировке на базе данных реальной блокировки не происходит. Вместо этого используется следующий подход - если во время выполнения транзакции она изменяет данные, которые были изменены после её начала, то транзакция прерывается с исключением. Использование оптимистичных блокировок позволяет избежать взаимных блокировок (dead-lock). Для реализации оптимистичной блокировки часто используется версионирование данных - в таблицу добавляется колонка, которая хранит текущую версию.</description>
    </item>
    
  </channel>
</rss>
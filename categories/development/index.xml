<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>development on Sharing knowledge</title>
    <link>https://uthark.github.io/categories/development/</link>
    <description>Recent content in development on Sharing knowledge</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Apr 2014 00:10:10 +0000</lastBuildDate>
    
	<atom:link href="https://uthark.github.io/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using Unitils ReflectionAssert</title>
      <link>https://uthark.github.io/2014/04/16/using-unitils-reflectionassert/</link>
      <pubDate>Wed, 16 Apr 2014 00:10:10 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/04/16/using-unitils-reflectionassert/</guid>
      <description>Often it is needed to compare two different instances of the class inside test. I.e. we save object into database, then fetch it back from db and we want to be sure if nothing was lost during saving/reading.
In order to make such assertions more easier and maintainable one can use great Unitils library which has useful class ReflectionAssert
First, update parent&amp;rsquo;s pom.xml:
&amp;lt;properties&amp;gt; &amp;lt;unitils.version&amp;gt;3.4&amp;lt;/unitils.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.unitils&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;unitils-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${unitils.version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; Then add dependency to the child module:</description>
    </item>
    
    <item>
      <title>Using AssertJ</title>
      <link>https://uthark.github.io/2014/04/15/using-assertj/</link>
      <pubDate>Tue, 15 Apr 2014 23:37:49 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/04/15/using-assertj/</guid>
      <description>AssertJ is a library which provides fluent strongly-typed assertions to use in unit tests.
Example of assertions written with AssertJ:
import io.github.uthark.blog.assertj.Assertions.assertThat; // ... within @Test User result = userDao.findByLogin(&amp;#34;username&amp;#34;); assertThat(result). isNotNull(). isActive(). hasLogin(&amp;#34;username&amp;#34;); As you can see assertions look much more readable. The integration of assertj into Maven project is very easy:
 Update pom.xml in parent module  &amp;lt;properties&amp;gt; &amp;lt;assertj-core.version&amp;gt;1.6.0&amp;lt;/assertj-core.version&amp;gt; &amp;lt;assertj-assertions-generator-maven-plugin.version&amp;gt;1.2.0&amp;lt;/assertj-assertions-generator-maven-plugin.version&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.assertj&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;assertj-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${assertj-core.version}&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;pluginManagement&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>Initializing Mockito @Mocks with JUnit @Rule</title>
      <link>https://uthark.github.io/2014/03/28/initializing-at-mocks-with-junit-at-rule/</link>
      <pubDate>Fri, 28 Mar 2014 13:24:45 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/28/initializing-at-mocks-with-junit-at-rule/</guid>
      <description>In this post I will show how one can implement custom JUnit @Rule.
As an example let&amp;rsquo;s take Mockito and implement custom rule which will initialize Mocks in test class.
By default, Mockito provides the following methods of mock initialization:
  Using Mockito.mock
Initialize mocks with Mockito.mock:
public void FooTest { private Foo foo; @Before public void setUp() { FooDependency dep = Mockito.mock(FooDependency.class); foo = new Foo(dep); } } This is the simplest case.</description>
    </item>
    
    <item>
      <title>Life fee</title>
      <link>https://uthark.github.io/2014/03/14/life-fee/</link>
      <pubDate>Fri, 14 Mar 2014 23:42:10 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/14/life-fee/</guid>
      <description>Found in sources:
try { // do some business logic. } catch (Exception e) { errorBean.addError(&amp;#34;System exception. Unable to locate life fee.&amp;#34;); } This is just awesome!</description>
    </item>
    
    <item>
      <title>Limiting threads count for GreenRobot EventBus</title>
      <link>https://uthark.github.io/2014/03/06/limiting-threads-count-for-greenrobot-eventbus/</link>
      <pubDate>Thu, 06 Mar 2014 22:38:54 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/06/limiting-threads-count-for-greenrobot-eventbus/</guid>
      <description>In one of my projects I used EventBus library. The library is pretty cool and I would recommend everybody to use it.
But I found one small issue with this library - in case you send too many events very fast (i.e. more than 1000 per second) you may face issue with application crash due to inability to create new thread.
The problem is lying in the used ExecutorService:
package de.</description>
    </item>
    
    <item>
      <title>Using custom font in Android TextView</title>
      <link>https://uthark.github.io/2014/03/06/customizing-font-in-android-textview/</link>
      <pubDate>Thu, 06 Mar 2014 19:13:17 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/06/customizing-font-in-android-textview/</guid>
      <description>Today I want to share with you custom TextView which allows to set font to be used in xml layout.
First, we need to declare our custom styleable
attrs.xml:
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;resources&amp;gt; &amp;lt;declare-styleable name=&amp;#34;TypefaceTextView&amp;#34;&amp;gt; &amp;lt;attr name=&amp;#34;typeface&amp;#34; format=&amp;#34;string&amp;#34;/&amp;gt; &amp;lt;/declare-styleable&amp;gt; &amp;lt;/resources&amp;gt; Then we need to create subclass of TextView which will use custom attribute.
TypefaceTextView:
public class TypefaceTextView extends TextView { public TypefaceTextView(Context context) { this(context, null); } public TypefaceTextView(Context context, AttributeSet attrs) { this(context, attrs, 0); } public TypefaceTextView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); TypedArray ta = context.</description>
    </item>
    
    <item>
      <title>Solving issue with DB2 on VMWare Fusion on MacBook Pro 2013 Late</title>
      <link>https://uthark.github.io/2014/03/05/solving-issue-with-db2-on-vmware-fusion-on-macbook-pro-2013-late/</link>
      <pubDate>Wed, 05 Mar 2014 14:41:54 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/05/solving-issue-with-db2-on-vmware-fusion-on-macbook-pro-2013-late/</guid>
      <description>Today I found issue running DB2 10.1 under VMWare Fusion 6.0.2 on my MacBook - all management services for db2 are starting except for the db2 instance itself.
When I tried to start DB2 using db2start it just crashed without any additional information.
After some googling I found out that it is due to the fact that current version of DB2 can&amp;rsquo;t handle more than 4 responses to CPUID query.</description>
    </item>
    
    <item>
      <title>Fixing unescaped quotes in page rendering in Octopress</title>
      <link>https://uthark.github.io/2014/03/02/octopress-quote-fix/</link>
      <pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/02/octopress-quote-fix/</guid>
      <description>When I created About Me page I found issue with rendering: for some reason styles and some javascripts were missing on the page.
Investigation showed that content in meta tag description contained unquoted quotes, thus resulting in broken HTML.
After searching within octopress sources I found the issue:
Rendering of description tag, excerpt from _includes/head.html:
{% capture description %} {% if page.description %} {{ page.description }} {% else %} {{ content | raw_content }} {% endif %} {% endcapture %} &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;{{ description | strip_html | condense_spaces | truncate:150 }}&amp;#34;&amp;gt; After capturing, description is being processed with filters, defined in plugins/octopress_filters.</description>
    </item>
    
    <item>
      <title>Using iTerm triggers</title>
      <link>https://uthark.github.io/2014/03/02/iterm-triggers/</link>
      <pubDate>Sun, 02 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/02/iterm-triggers/</guid>
      <description>I want to share one of the cool features which iTerm.app has - triggers. The idea behind triggers is simple - it allows to perform arbitrary action based on the output in console window. For example, it can colorize specified content (based on regular expressions).
Start iTerm, open settings (⌘+,), go to Profiles, then tab Advanced. Click on Edit button in Triggers section.
  iTerm Settings   Then you can define your own triggers:</description>
    </item>
    
    <item>
      <title>Automatic query modification with Spring Data Mongo</title>
      <link>https://uthark.github.io/2014/03/01/restricting-mongo-template/</link>
      <pubDate>Sat, 01 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2014/03/01/restricting-mongo-template/</guid>
      <description>Introduction Today I want to show how one can automatically apply additional restrictions on MongoDB Queries with MongoTemplate or Spring Data Mongo.
Implementation First, let&amp;rsquo;s introduce interface QueryModifier.
import org.springframework.data.mongodb.core.query.Query; public interface QueryModifier { /** * Modifies source query according to the rules. * @param query Source query to modify. * @param collectionName name of the collection against which query will be executed. * @return Modified query. */ Query modify(Query query, String collectionName); } Implementations of this interface will pickup original query and modify it somehow.</description>
    </item>
    
    <item>
      <title>Пишем @Enable*-аннотацию для Spring</title>
      <link>https://uthark.github.io/2013/06/29/spring-enable-annotation/</link>
      <pubDate>Sat, 29 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2013/06/29/spring-enable-annotation/</guid>
      <description>Начиная с версии 3.1 Spring поддерживает декларативное включение необходимой функциональности через, так называемые, @Enable* аннотации. Пример таких аннотаций: org.springframework.web.servlet.config.annotation.EnableWebMvc, org.springframework.cache.annotation.EnableCaching, org.springframework.scheduling.annotation.EnableAsync и другие.
В продолжение темы прошлого поста, я хочу показать, как можно добавить собственную @Enable аннотацию.
Для автоматического создания клиента для REST-ресурса нам необходима следующая информация:
 Пакет, в котором искать интерфейсы, проаннотированные аннотацией @Path() Базовый адрес REST-приложения.  Для того, чтобы передать эту информацию, мы создадим два атрибута в аннотации: scanPackage() и endpoint()</description>
    </item>
    
    <item>
      <title>@Autowired JAX-RS Client API</title>
      <link>https://uthark.github.io/2013/06/28/jaxrs-spring-autowiring/</link>
      <pubDate>Fri, 28 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2013/06/28/jaxrs-spring-autowiring/</guid>
      <description>Продолжая разговор о JAX RS Client API - предположим, что мы уже используем JAX-RS клиент
У нас есть класс, который умеет создавать прокси для любого REST-интерфейса в проекте. Теперь мы хотим сделать так, чтобы эти интерфейсы можно было автоматически создавать в контексте Spring и связывать с другими бинами.
Первое решение, которое приходит в лоб - объявить бин в конфигурации для каждого интерфейса:
@Configuration public class SpringConfiguration { @Bean public UserRest userRest(){ List&amp;lt;?</description>
    </item>
    
    <item>
      <title>JAX-RS Client API</title>
      <link>https://uthark.github.io/2013/06/28/jaxrs/</link>
      <pubDate>Fri, 28 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2013/06/28/jaxrs/</guid>
      <description>JAX-RS - набор Java API для работы с REST сервисами. Существует несколько реализаций, о которых я уже писал раньше.
Предположим, что проект А выставляет наружу REST API, который мы хотим использовать в проекте Б. Очевидно, что сразу возникает вопрос - можно ли переиспользовать классы модели и интерфейс в другом проекте. Ответ - да, можно. Client API, появившийся в JAX RS 2.0, упрощает реализацию клиента, но это всё равно не самый оптимальный вариант.</description>
    </item>
    
    <item>
      <title>@Autowiring EJBs with Spring</title>
      <link>https://uthark.github.io/2013/06/19/autowiring-factorybean/</link>
      <pubDate>Wed, 19 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2013/06/19/autowiring-factorybean/</guid>
      <description>Предположим, что у нас есть проект на Spring, в котором необходимо использовать внешние EJB. Для получения бинов необходимо создавать InitialContext и делать lookup() нужных ejb. Но эту задачу можно автоматизировать и пользоваться @Autowired, то есть код будет выглядеть вот так:
@Service public class UserService { @Autowired private UserRemoteBean userRemoteBean; } Для этого в Spring существует FactoryBean - класс, который знает, как создавать бины нужного типа. Собственно, нам необходимо написать такой класс (код на Scala):</description>
    </item>
    
    <item>
      <title>Валидация входных параметров с использованием Spring</title>
      <link>https://uthark.github.io/2013/06/19/validation/</link>
      <pubDate>Wed, 19 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2013/06/19/validation/</guid>
      <description>Очень часто возникает задача проверки входных параметров в сервис на корректность с точки зрения бизнес логики.
Эту задачу можно решить в лоб, написав вручную код валидации в каждом из методов сервиса, например, вот так:
public User save(User user) { if(user == null) { throw new IllegalArgumentException(&amp;#34;User is null&amp;#34;); } // other checks  //...  // business logic starts here...  //...  return savedUser; } Очевидно, что если в каждом методе делать такие проверки, то код бизнес-логики загрязняется проверками, что ухудшает читаемость кода.</description>
    </item>
    
    <item>
      <title>Использование memcached в качестве backend для Spring Caching Abstraction</title>
      <link>https://uthark.github.io/2013/06/19/spring-caching/</link>
      <pubDate>Wed, 19 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2013/06/19/spring-caching/</guid>
      <description>В Spring 3.1 появился замечательный модуль - Spring Cache, который является абстракцией над кэшированием, что позволяет декларативно реализовывать кэширование в приложении.
Я не буду вдаваться в подробности работы, их можно прочитать в документации, но опишу, каким образом можно настроить memcached в качестве бэкэнда для работы.
Подключение зависимостей &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.code.simple-spring-memcached&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spymemcached-provider&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.google.code.simple-spring-memcached&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cache&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; spymemcached-provider - это библиотечка для работы с memcached из Java, а spring-cache - модуль интеграции со Spring.</description>
    </item>
    
    <item>
      <title>Пишем валидатор для Bean Validation API</title>
      <link>https://uthark.github.io/2013/06/19/custom-bean-validator/</link>
      <pubDate>Wed, 19 Jun 2013 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2013/06/19/custom-bean-validator/</guid>
      <description>JSR-303 предоставляет удобный API для проверки валидности объектов, а также входных параметров. Очевидно, что стандартных валидаторов в какой-то момент может быть недостаточно, поэтому необходимо писать собственный.
Хочу показать на примере валидации запроса к MongoDB, как легко это делается.
Создание аннотации @Target({FIELD, PARAMETER}) @Retention(RUNTIME) @Documented @Constraint(validatedBy = {MongoQueryValidator.class}) public @interface MongoQuery { String message() default &amp;#34;Invalid mongo query&amp;#34;; Class&amp;lt;?&amp;gt;[] groups() default {}; Class&amp;lt;? extends Payload&amp;gt;[] payload() default {}; } Обратите внимание на аннотацию @Constraint - она описывает, какой класс будет проводить реальную валидацию.</description>
    </item>
    
    <item>
      <title>Автоматизируем работу с виртуальными машинами с помощью Vagrant</title>
      <link>https://uthark.github.io/2012/10/24/vagrant/</link>
      <pubDate>Wed, 24 Oct 2012 00:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/10/24/vagrant/</guid>
      <description>Современные enterprise проекты очень часто имеют очень сложную инфраструктуру для развёртывания. Кроме того, во время разработки часто используются виртуальные машины. Например, может использоваться несколько виртуальных машин, на которых развёрнуты различные конфигурации софта.
Vagrant - это средство для управления виртуальными машинами на базе Virtualbox.
Возможности  Создание виртуальных машин с определённой, заранее заданной, конфигурацией. Лёгкое создание копии виртуальной машины, используя заранее подготовленный образ. Осуществление provisioning для новых виртуальных машин.  Работа с Vagrant Для начала необходимо установить Virtualbox и Vagrant.</description>
    </item>
    
    <item>
      <title>Собственная реализация методов в Spring Data JPA</title>
      <link>https://uthark.github.io/2012/04/28/spring-data-jpa_28/</link>
      <pubDate>Sat, 28 Apr 2012 15:03:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/28/spring-data-jpa_28/</guid>
      <description>Очевидно, что мы не всегда можем воспользоваться автоматической генерацией кода, предоставляемой Spring Data JPA. Например, у нас слишком сложный запрос, или нам необходимо вызвать процедуру в базе данных, либо у нас сложная бизнес-логика.
Рассмотрим следующий пример - например, нам нужна функциональность уникального счётчика, который мы решили реализовать с помощью последовательности (sequence).
Сначала определим интерфейс, в котором опишем все методы, которые мы будем реализовывать самостоятельно. В нашем случае, это будет только один метод:</description>
    </item>
    
    <item>
      <title>Ищем с помощью Spring Data JPA</title>
      <link>https://uthark.github.io/2012/04/24/spring-data-jpa/</link>
      <pubDate>Tue, 24 Apr 2012 14:04:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/24/spring-data-jpa/</guid>
      <description>Рассмотрим подробнее одну из наиболее полезных вещей в Spring Data JPA - генерация JPQL-запросов на основе имени метода.
Spring Data JPA умеет автоматически генерировать запросы используя для подсказки название метода.
Например, метод User.findByLoginAndPassword сгенерирует примерно следующий код:
FROM User u where u.login = :login and password = :password Вообще Spring Data JPA пытается быть умным, поэтому реализация findBy{&amp;hellip;}методов ищется следующим образом:
У @Queryследующие плюсы:
Очевидно, что при использовании запросов нам необходимо каким-то образом указывать параметры для запросов.</description>
    </item>
    
    <item>
      <title>Использование BeanPostProcessor на примере журналирования</title>
      <link>https://uthark.github.io/2012/04/20/beanpostprocessor/</link>
      <pubDate>Fri, 20 Apr 2012 15:51:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/20/beanpostprocessor/</guid>
      <description>Сегодня я хочу рассказать, как можно сделать инициализацию логгера в классе с использованием аннотаций и BeanPostProcessorОчень часто мы инициализируем логгер следующим образом:
public class MyClass { private static final Logger LOG = LoggerFactory.getLogger(MyClass.class); } Я покажу, как сделать, чтобы можно было писать вот так:
@Log private Logger LOG; Первым делом нам нужно объявить аннотацию:
@Retention(RUNTIME) @Target(FIELD) @Documented public @interface Log { String category() default &amp;#34;&amp;#34;; } А вторым делом, написать собственный BeanPostProcessor, который бы устанавливал нам логгер:</description>
    </item>
    
    <item>
      <title>Преобразуем строку в дату</title>
      <link>https://uthark.github.io/2012/04/20/blog-post/</link>
      <pubDate>Fri, 20 Apr 2012 15:25:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/20/blog-post/</guid>
      <description>Казалось бы, есть простейшая задача - преобразовать строковое представление даты в объект класса java.util.Date.
Как оказалось, иногда использование DateFormat не помогает. В случае, если строка - это заголовок Dateиз письма, то нам нужно использовать javax.mail.internet.MailDateFormatдля преобразования такой строки.
String dateStr = ... Date parsedDate = new MailDateFormat().parse(dateStr); </description>
    </item>
    
    <item>
      <title>Упрощаем работу с JPA при помощи Spring Data JPA</title>
      <link>https://uthark.github.io/2012/02/23/jpa-spring-data-jpa/</link>
      <pubDate>Thu, 23 Feb 2012 02:17:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/02/23/jpa-spring-data-jpa/</guid>
      <description>Несмотря на то, что проект только недавно достиг версии 1.0, у него достаточно богатая история - раньше он развивался в рамках проекта Hades.
Итак, для начала нам необходимо объявить DAO-интерфейс, в котором мы будем объявлять методы для работы с сущностью.
public interface UserRepository extends CrudRepository&amp;amp;lt;User, Long&amp;amp;gt; { } Данного кода достаточно для обычного DAO с CRUD-методами.
Полный список методов, объявленный в CrudRepository можно посмотреть в javadoc.
В случае, если нам нужны не все методы, то есть возможность произвести наследование от интерфейса Repositoryи перенести в наследника только те методы из интерфейса CrudRepository, которые нужны.</description>
    </item>
    
    <item>
      <title>Разработка и тестирование Java REST веб-сервисов</title>
      <link>https://uthark.github.io/2012/02/09/java-rest/</link>
      <pubDate>Thu, 09 Feb 2012 01:05:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/02/09/java-rest/</guid>
      <description>import javax.ws.rs.*; import javax.ws.rs.core.MediaType; @Path(&amp;#34;/service/entity&amp;#34;) @Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON}) public interface EntityRestService { @GET @Path(&amp;#34;/all&amp;#34;) EntityList listAll(); @GET @Path(&amp;#34;/{id}&amp;#34;) Entity findById(@PathParam(&amp;#34;id&amp;#34;) Integer id); } Создаём интерфейс, в котором расставляем JAX-RS аннотации. Аннотация @Pathуказывает путь, по которому будет доступен наш сервис. Аннотация @GETопределяет, какой HTTP-запрос будет обрабатываться данным методом. Аннотация @Producesпозволяет указать, в каком формате данный сервис предоставляет результаты.
Конфигурация очень проста, во-первых, нам нужно добавить обновить pom.xmlи добавить необходимые зависимости:
Добавляем compile-time зависимость на JAX-RS API</description>
    </item>
    
    <item>
      <title>Немножко магии от AspectJ</title>
      <link>https://uthark.github.io/2012/01/28/aspectj/</link>
      <pubDate>Sat, 28 Jan 2012 02:43:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/01/28/aspectj/</guid>
      <description>Наверно, вы уже сталкивались с таким понятием, как AOП - аспектно-ориентированное программирование.
Обычно, про него вспоминают, когда говорят про декларативное использование транзакций, про проверку прав доступа, либо про реализацию журналирования.
Но это не единственные области применения АОП.
Я хочу показать ещё пару областей применения из реальных проектов:
 Модификация исходного кода для реализации дополнительных возможностей. Принудительная проверка контракта между модулями.  Модификация исходного кода для реализации дополнительных возможностей Предположим, что у нас есть модуль в приложении, который предоставляет нужную нам функциональность.</description>
    </item>
    
    <item>
      <title>Немного о виртуальных методах в Java</title>
      <link>https://uthark.github.io/2011/07/21/java/</link>
      <pubDate>Thu, 21 Jul 2011 12:06:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2011/07/21/java/</guid>
      <description>Сегодня я хочу рассмотреть некоторые особенности переопределения методов в Java. В java нельзя переопределить: public class A { int i = 3; int getI() {return i;} } public class B extends A{ int i = 5; int getI() {return i;} } A a = new B(); System.out.println(a.i); System.out.println(a.getI()); Вопрос: что выведет данный код?Ответ:  Так как поля класса не наследуются, то у класса A своё поле i и у класса B тоже своё поле i.</description>
    </item>
    
    <item>
      <title>Сокращаем ссылки на андроиде</title>
      <link>https://uthark.github.io/2010/12/06/blog-post/</link>
      <pubDate>Mon, 06 Dec 2010 23:11:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/12/06/blog-post/</guid>
      <description>import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.NameValuePair; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.utils.URIUtils; import org.apache.http.client.utils.URLEncodedUtils; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import org.json.JSONException; import org.json.JSONObject; import android.util.Log; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import java.util.ArrayList; import java.util.List; /** * Helper class to work with bitly. * * @author Oleg Atamanenko * @since 06-Dec-2010 12:49:36 */ public class Bitly { private static final String TAG = &amp;#34;Bitly&amp;#34;; private static final String SHORTEN = &amp;#34;/v3/shorten&amp;#34;; private static final String API_URL = &amp;#34;api.</description>
    </item>
    
    <item>
      <title>Удаление различных диакритических символов из строки</title>
      <link>https://uthark.github.io/2010/05/22/blog-post/</link>
      <pubDate>Sat, 22 May 2010 00:52:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/05/22/blog-post/</guid>
      <description>package com.blogspot.atamanenko; import java.text.Normalizer; import java.text.Normalizer.Form; public class StringNormalizer { public static String normalize(String string) { return Normalizer.normalize(string, Form.NFD) .replaceAll(&amp;#34;\\p{InCombiningDiacriticalMarks}+&amp;#34;, &amp;#34;&amp;#34;); } } Вызов Normalizer.normalizeпроводит нормализациювходной строки. Последующий вызов регулярного выражения удаляет все диакритические знаки, полученные после нормализации.</description>
    </item>
    
    <item>
      <title>Создание больших объёмов тестовых данных с помощью Databene Benerator</title>
      <link>https://uthark.github.io/2010/05/22/databene-benerator/</link>
      <pubDate>Sat, 22 May 2010 00:26:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/05/22/databene-benerator/</guid>
      <description>&amp;amp;lt;project xmlns=&amp;amp;quot;http://maven.apache.org/POM/4.0.0&amp;amp;quot; xmlns:xsi=&amp;amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;amp;quot; xsi:schemaLocation=&amp;amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&amp;amp;quot;&amp;amp;gt; &amp;amp;lt;modelVersion&amp;amp;gt;4.0.0&amp;amp;lt;/modelVersion&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;com.myorganization&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;databene-benerator-test&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;1.0&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;packaging&amp;amp;gt;jar&amp;amp;lt;/packaging&amp;amp;gt; &amp;amp;lt;name&amp;amp;gt;data generation project&amp;amp;lt;/name&amp;amp;gt; &amp;amp;lt;dependencies&amp;amp;gt; &amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;org.databene&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;databene-benerator&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;0.5.9&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;/dependency&amp;amp;gt; &amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;org.databene&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;databene-webdecs&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;0.4.9&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;/dependency&amp;amp;gt; &amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;org.databene&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;databene-commons&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;0.4.9&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;/dependency&amp;amp;gt; &amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;mysql&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;mysql-connector-java&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;5.1.6&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;/dependency&amp;amp;gt; &amp;amp;lt;/dependencies&amp;amp;gt; &amp;amp;lt;build&amp;amp;gt; &amp;amp;lt;resources&amp;amp;gt; &amp;amp;lt;resource&amp;amp;gt; &amp;amp;lt;directory&amp;amp;gt;src/main/resources&amp;amp;lt;/directory&amp;amp;gt; &amp;amp;lt;filtering&amp;amp;gt;true&amp;amp;lt;/filtering&amp;amp;gt; &amp;amp;lt;/resource&amp;amp;gt; &amp;amp;lt;/resources&amp;amp;gt; &amp;amp;lt;plugins&amp;amp;gt; &amp;amp;lt;plugin&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;org.apache.maven.plugins&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;maven-compiler-plugin&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;configuration&amp;amp;gt; &amp;amp;lt;encoding&amp;amp;gt;UTF-8&amp;amp;lt;/encoding&amp;amp;gt; &amp;amp;lt;source&amp;amp;gt;1.5&amp;amp;lt;/source&amp;amp;gt; &amp;amp;lt;target&amp;amp;gt;1.5&amp;amp;lt;/target&amp;amp;gt; &amp;amp;lt;/configuration&amp;amp;gt; &amp;amp;lt;/plugin&amp;amp;gt; &amp;amp;lt;plugin&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;org.databene&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;maven-benerator-plugin&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;0.5.9&amp;amp;lt;/version&amp;amp;gt; &amp;amp;lt;executions&amp;amp;gt; &amp;amp;lt;execution&amp;amp;gt; &amp;amp;lt;phase&amp;amp;gt;compile&amp;amp;lt;/phase&amp;amp;gt; &amp;amp;lt;goals&amp;amp;gt; &amp;amp;lt;goal&amp;amp;gt;generate&amp;amp;lt;/goal&amp;amp;gt; &amp;amp;lt;/goals&amp;amp;gt; &amp;amp;lt;/execution&amp;amp;gt; &amp;amp;lt;/executions&amp;amp;gt; &amp;amp;lt;configuration&amp;amp;gt; &amp;amp;lt;descriptor&amp;amp;gt;src/main/resources/benerator.ben.xml&amp;amp;lt;/descriptor&amp;amp;gt; &amp;amp;lt;encoding&amp;amp;gt;UTF-8&amp;amp;lt;/encoding&amp;amp;gt; &amp;amp;lt;validate&amp;amp;gt;true&amp;amp;lt;/validate&amp;amp;gt; &amp;amp;lt;dbUrl&amp;amp;gt;jdbc:mysql://localhost:3306/hrtool?useUnicode=true&amp;amp;amp;characterEncoding=UTF-8&amp;amp;lt;/dbUrl&amp;amp;gt; &amp;amp;lt;dbDriver&amp;amp;gt;com.mysql.jdbc.Driver&amp;amp;lt;/dbDriver&amp;amp;gt; &amp;amp;lt;dbSchema&amp;amp;gt;database&amp;amp;lt;/dbSchema&amp;amp;gt; &amp;amp;lt;dbUser&amp;amp;gt;user&amp;amp;lt;/dbUser&amp;amp;gt; &amp;amp;lt;dbPassword&amp;amp;gt;password&amp;amp;lt;/dbPassword&amp;amp;gt; &amp;amp;lt;/configuration&amp;amp;gt; &amp;amp;lt;dependencies&amp;amp;gt; &amp;amp;lt;dependency&amp;amp;gt; &amp;amp;lt;groupId&amp;amp;gt;log4j&amp;amp;lt;/groupId&amp;amp;gt; &amp;amp;lt;artifactId&amp;amp;gt;log4j&amp;amp;lt;/artifactId&amp;amp;gt; &amp;amp;lt;version&amp;amp;gt;1.</description>
    </item>
    
    <item>
      <title>Несколько слов о GORM</title>
      <link>https://uthark.github.io/2010/04/11/gorm/</link>
      <pubDate>Sun, 11 Apr 2010 11:45:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/04/11/gorm/</guid>
      <description>class Person implements Serializable { static hasMany = [ scores: ScoreSheet ] static mapping = { scores joinTable: false }; } class Note implements Serializable { static belongsTo = [ person: Person ] } class Person implements Serializable { // person fields. } class Payment { Long id Long version Integer amount static mapping = { tablePerHierarchy false } } class CreditCardPayment extends Payment { String cardNumber } </description>
    </item>
    
    <item>
      <title>Общение со Skype через D-Bus на Python</title>
      <link>https://uthark.github.io/2010/03/22/skype-d-bus-python/</link>
      <pubDate>Mon, 22 Mar 2010 23:50:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/03/22/skype-d-bus-python/</guid>
      <description>#!/bin/sh  # Stop amarok dbus-send --session --type=method_call --dest=org.kde.amarok /Player org.freedesktop.MediaPlayer.Stop # Logout from kopete dbus-send --session --type=method_call --dest=org.kde.kopete /Kopete org.kde.Kopete.disconnectAll # Logout from Skype skypeapi.py &amp;#39;SET USERSTATUS OFFLINE&amp;#39; # Lock screen dbus-send --session --type=method_call --dest=org.freedesktop.ScreenSaver /ScreenSaver org.freedesktop.ScreenSaver.Lock Детали и параметры работы команды dbus-sendописаны в man-странице#!/usr/bin/env python import dbus, sys def main(): remote_bus = dbus.SessionBus() # Check if skype is running. system_service_list = remote_bus.get_object(&amp;#39;org.freedesktop.DBus&amp;#39;, &amp;#39;/org/freedesktop/DBus&amp;#39;).ListNames() skype_api_found = 0 for service in system_service_list: if service==&amp;#39;com.</description>
    </item>
    
    <item>
      <title>Разработка макроса для TiddlyWiki</title>
      <link>https://uthark.github.io/2010/03/21/tiddlywiki/</link>
      <pubDate>Sun, 21 Mar 2010 20:54:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/03/21/tiddlywiki/</guid>
      <description>/*{{{*/ version.extensions.faviconLinkMacro = {major: 0, minor: 1, revision: 0, date: new Date(2010,3,21)}; // Author: Oleg Atamanenko config.macros.faviconLink = {} config.macros.faviconLink.handler = function(place, macroName, params, wikifier, paramString) { var linkBox = createTiddlyElement(place, &amp;amp;quot;span&amp;amp;quot;, null, &amp;amp;quot;favIcon&amp;amp;quot;, &amp;amp;quot;&amp;amp;quot;); var args = paramString.parseParams(&amp;amp;quot;list&amp;amp;quot;,null,true); var link = getParam(args, &amp;amp;quot;link&amp;amp;quot;, &amp;#39;false&amp;#39;); if (link != &amp;#39;false&amp;#39;){ urlParts = link.split(&amp;#39;/&amp;#39;); imgLink = urlParts[0] + &amp;amp;quot;//&amp;amp;quot; + urlParts[2] + &amp;amp;quot;/favicon.ico&amp;amp;quot;;  var imgElement = createTiddlyElement(linkBox, &amp;amp;quot;img&amp;amp;quot;, null, &amp;amp;quot;faviconImage&amp;amp;quot;, &amp;amp;quot;&amp;amp;quot;); imgElement.</description>
    </item>
    
    <item>
      <title>Список для проверки при оптимизации Grails приложений</title>
      <link>https://uthark.github.io/2010/02/06/grails/</link>
      <pubDate>Sat, 06 Feb 2010 23:31:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/02/06/grails/</guid>
      <description>Выкладываю ниже список задач, которые нужно/можно выполнить для оптимизации приложения, написанного на Grails, может кому пригодится.
Тестирование проведённых оптимизаций Первым делом необходимо разработать критерии проверки, которые позволят оценить эффективность проведённых оптимизаций.
 Установить Java Melodyплагиндля Grails для проведения анализа. Разработать скрипты для проведения нагрузочного тестирования. Прогнать скрипты. Проанализировать результаты Java Melody, выявить узкие места, произвести нужные оптимизации.  Общие оптимизации Очень часто обновление до последней версии используемых библиотек попутно улучшает производительность.</description>
    </item>
    
    <item>
      <title>Вложенные транзакции в базах данных</title>
      <link>https://uthark.github.io/2010/02/05/blog-post/</link>
      <pubDate>Fri, 05 Feb 2010 01:20:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2010/02/05/blog-post/</guid>
      <description>Summary: Некоторые особенности вложенных транзакций.Иногда бывает так, что при обработке запроса необходимо открыть ещё одну транзакцию в рамках текущей транзакции. Это называется вложенной транзакцией. Очень многие базы данных не поддерживают вложенные транзакции вообще, например, MySQL и Oracle. А те, что поддерживают, делают это на минимальном уровне, например, Sybase поддерживает только псевдовложенные транзакции.Вложенные транзакции могут быть следующих видов:begin tran select @@trancount /* @@trancount = 1 */ begin tran select @@trancount /* @@trancount = 2 */ begin tran select @@trancount /* @@trancount = 3 */ commit tran commit tran commit tran select @@trancount /* @@ trancount = 0 */ </description>
    </item>
    
    <item>
      <title>Расширение для работы с Delicious доступно на сайте расширений Google Chrome</title>
      <link>https://uthark.github.io/2009/12/08/delicious-google-chrome/</link>
      <pubDate>Tue, 08 Dec 2009 23:43:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/12/08/delicious-google-chrome/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Создание страницы настроек для расширений Google Chrome</title>
      <link>https://uthark.github.io/2009/11/24/google-chrome/</link>
      <pubDate>Tue, 24 Nov 2009 23:09:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/11/24/google-chrome/</guid>
      <description>В продолжение предыдущей заметкиЛогично предположить, что у расширений могут быть настройки. В Google Chrome/Chromium для этого есть специальный API.Для того, чтобы создать собственную страницу настроек необходимо сделать следующее: Объявить в манифесте страницу настроек  Реализовать страницу с настройками.Страница с настройками - это обычная HTML-страничка. Для доступа к настройкам Google Chrome предоставляет объект localStorage, который умеет сохранять и возвращать значения.С объектом localStorageработа идёт как с обычным hash.   </description>
    </item>
    
    <item>
      <title>Расширение Delicious Bookmarks для Google Chrome/Chromium</title>
      <link>https://uthark.github.io/2009/11/14/delicious-bookmarks-google/</link>
      <pubDate>Sat, 14 Nov 2009 22:34:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/11/14/delicious-bookmarks-google/</guid>
      <description>&amp;ldquo;browser_action&amp;rdquo;: { // 5 &amp;ldquo;name&amp;rdquo;: &amp;ldquo;Save bookmark to delicious.com&amp;rdquo;, &amp;ldquo;default_title&amp;rdquo;: &amp;ldquo;Save bookmark to delicious.com&amp;rdquo;, &amp;ldquo;default_icon&amp;rdquo;: &amp;ldquo;delicious.20.gif&amp;rdquo; // optional },
&amp;ldquo;content_scripts&amp;rdquo;: [ // 6 { &amp;ldquo;matches&amp;rdquo;: [&amp;ldquo;http:///&amp;rdquo;, &amp;ldquo;https:///&amp;quot;], &amp;ldquo;js&amp;rdquo;: [&amp;ldquo;getDocumentSelection.js&amp;rdquo;] } ],
&amp;ldquo;options_page&amp;rdquo;: &amp;ldquo;options.html&amp;rdquo; // 7 } Манифест - файл в формате JSON.Манифест состоит из следующих частей: name- Имя расширения version- Версия расширения background_page- основной файл с расширением. Это обычный HTML-файл с разметкой. permissions- разрешения для расширения. Указываем, что нам нужен доступ к вкладкам (tabs) и закладкам (bookmarks).</description>
    </item>
    
    <item>
      <title>Двунаправленная ссылочная целостность</title>
      <link>https://uthark.github.io/2009/07/07/blog-post/</link>
      <pubDate>Tue, 07 Jul 2009 22:11:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/07/07/blog-post/</guid>
      <description>Здравствуйте.
Я считаю, что разработчику всегда стоит иметь представление о том, как работают низлежащие абстракции. Хотя бы потому, что часто абстракциибываютпротекающими.
А веду я это к тому, что когда фреймворк вываливает стектрейс с несколькими вложенными (и, часто, для непосвященных непонятными) исключениями, то бывает непонятно, что с этим делать, особенно, если не знаешь, как реализована абстракция.
Иногда бывает нужно хранить двунаправленные связи между таблицами. Например, есть игрок и есть его статистика и нужно, чтобы каждая из сущностей знала про другую.</description>
    </item>
    
    <item>
      <title>Spring Roo (часть 2)</title>
      <link>https://uthark.github.io/2009/06/06/spring-roo-2/</link>
      <pubDate>Sat, 06 Jun 2009 22:19:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/06/06/spring-roo-2/</guid>
      <description>Action.java Класс содержит только полезную с точки зрения назначения класса информацию. По сути, то, что вводит разработчик в консоль Roo аккумулируется здесь. Весь дополнительный код разносится по другим классам.  @Entity //1 @RooJavaBean //2 @RooToString //3 @RooEntity(finders = { &amp;#34;findActionsByName&amp;#34; }) //4 public class Action { @NotNull @Size(min = 1, max = 80) private String name; @Size(max = 1024) private String description; } Мы видим, что:
 Класс является JPA-сущностью.</description>
    </item>
    
    <item>
      <title>Введение в Spring Roo</title>
      <link>https://uthark.github.io/2009/06/03/spring-roo/</link>
      <pubDate>Wed, 03 Jun 2009 00:06:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/06/03/spring-roo/</guid>
      <description>Недавнокомпания Spring Sourceпрезентовала новый продукт - Spring Roo. Цель проекта- повысить продуктивность Java-разработчиков. Почитавобзоры, а также потрогав его рукамиможно сделать вывод о том, что это, в некотором виде, альтернатива AppFuseи Grails.</description>
    </item>
    
    <item>
      <title>Apache Ant и Metro</title>
      <link>https://uthark.github.io/2009/06/02/apache-ant-metro/</link>
      <pubDate>Tue, 02 Jun 2009 23:31:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/06/02/apache-ant-metro/</guid>
      <description>Столкнулся с такой проблемой - в некоторых случаях приложение, собранное антом не работает. Конкретно - не работает десереализация запросов на веб-сервис. Получаемый запрос содержит nullв значениях полей.
Опытным путём было выяснено, что на это влияет используемая версия Java. Под 1.5 работает корректно, под 1.6 - не работает. Нашли ошибку в метро, связанную именно с версией JDK и на этом успокоились. Но было одно исключение из правил. У одного из разработчиков под 1.</description>
    </item>
    
    <item>
      <title>Использование модификатора protected на полях в базовом классе</title>
      <link>https://uthark.github.io/2009/05/30/protected/</link>
      <pubDate>Sat, 30 May 2009 23:45:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/05/30/protected/</guid>
      <description>Недавно задали мне вопрос - что я думаю об использовании модификатора protected для членов базового класса? Под этим вопросом кроются более серьёзные вещи.
Например, любой член класса, имеющий модификатор protected, расширяет интерфейс базового класса для подклассов - подклассы имеют доступ ко всем protected и public методам этого поля. Иногда это сделано специально, например, для того, чтобы подклассы могли иметь доступ к какой-либо функциональности. Однако, если подкласс будет использовать protected поля неправильно (например, он может установить его в null, нарушив, таким образом, поведение базового класса), то это не принесёт пользы.</description>
    </item>
    
    <item>
      <title>Сферический программист в вакууме и абстрактное понятие качества кода в условиях Fixed-Price проектов (часть 2)</title>
      <link>https://uthark.github.io/2009/05/27/fixed-price-2/</link>
      <pubDate>Wed, 27 May 2009 01:26:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/05/27/fixed-price-2/</guid>
      <description>Причин для написания плохого кода может быть несколько. Некоторые из них лежат на поверхности:
Невнимательность- через это проходят почти все. Почти каждый сможет вспомнить случай, когда не был сделан svn addперед коммитом. Эта проблема решается обычно самомотивацией человека на хороший код. Впрочем, команда и сервер непрерывной интеграции тоже прилагают усилия для того, чтобы человек проверил ещё раз то, что он хочет выложить в репозиторий.
Некомпетентность- эта причина пересекается с недостатком опыта, но, при этом отлична от неё.</description>
    </item>
    
    <item>
      <title>Сферический программист в вакууме и абстрактное понятие качества кода в условиях Fixed-Price проектов (часть 1)</title>
      <link>https://uthark.github.io/2009/05/27/fixed-price-1/</link>
      <pubDate>Wed, 27 May 2009 00:36:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/05/27/fixed-price-1/</guid>
      <description>В последнее время всё чаще задумываюсь о том, почему разработчики пишут плохой и некачественный код. Под кодом я подразумеваю не только сам код, но и, в том числе, архитектуру и дизайн.
Плохим кодом я считаю следущий:
Если код не выполняет нефункциональные требования, то это говорит о том, что либо дизайн, либо реализация, не учли требования и это тоже не добавляет удовлетворённости конечному пользователю. Часто здесь можно провести рефакторинг, но бывает и так, что архитектурные ошибки не дают в принципе выполнить нефункциональные требования, либо их реализация требует очень больших временных затрат.</description>
    </item>
    
    <item>
      <title>Google Application Engine</title>
      <link>https://uthark.github.io/2009/05/23/google-application-engine/</link>
      <pubDate>Sat, 23 May 2009 23:00:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/05/23/google-application-engine/</guid>
      <description>Посмотрел на Google App Engine (GAE).
При своей цене (= бесплатно) это очень хороший сервис.
GAE - это инфраструктура для запуска веб-приложений на серверах Google. То, что сейчас модно называть cloud computing.
На презентации платформы в 2008 годуGoogle объявил только о поддержке Python. Год спустя, в апреле 2009 года Google заявил о поддержке Java, правда с ограничениями. Собственно, поддержка Javaи была тем самым толчком, что я решил поближе посмотреть на платформу.</description>
    </item>
    
    <item>
      <title>Eclipse и его расширения</title>
      <link>https://uthark.github.io/2009/05/03/eclipse/</link>
      <pubDate>Sun, 03 May 2009 00:18:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/05/03/eclipse/</guid>
      <description>Многие ругают Eclipseза то, что там нет многого из того, что есть в коробке у Jetbrains Intellij IDEA. Мне всегда казалось это не очень корректным, так как Eclipse в первую очередь платформа, а уже потом - среда для Java разработки.Решил собрать воедино весь список используемых мною расширений для Eclipse.</description>
    </item>
    
    <item>
      <title>Критерии выбора блокировок</title>
      <link>https://uthark.github.io/2009/04/26/blog-post_26/</link>
      <pubDate>Sun, 26 Apr 2009 15:30:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/04/26/blog-post_26/</guid>
      <description>Так как использование блокировок по-разному влияет на производительность, необходимо выбирать, в каких случаях какой вид блокировок лучше использовать.</description>
    </item>
    
    <item>
      <title>Транзакции в реляционных базах данных</title>
      <link>https://uthark.github.io/2009/04/24/blog-post_24/</link>
      <pubDate>Fri, 24 Apr 2009 21:49:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/04/24/blog-post_24/</guid>
      <description>При работе в многопользовательском окружении может возникнуть ситуация, когда разные пользователи или системы обновляют одни и те же данные. Это может привести к ситуации, когда один из пользователей изменит данные, которые уже изменял другой пользователь и приведёт либо к потере данных, либо к переводу данных в неконсистентное состояние. Для решения этой проблемы были придуманы транзакции. Целью транзакции является создание абстракции того, что каждый пользователь - единственный в системе.
Характеристики транзакций В конце 1970-х Джим Грейвыделил следующие характеристики транзакций:</description>
    </item>
    
    <item>
      <title>Кратко о блокировках в БД</title>
      <link>https://uthark.github.io/2009/04/22/blog-post_22/</link>
      <pubDate>Wed, 22 Apr 2009 23:58:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2009/04/22/blog-post_22/</guid>
      <description>Блокировка - в реляционных базах данных это установка метки на запись, что запись заблокирована для изменений.
Существует два вида блокировок - оптимистичная и пессимистичная.
Оптимистичная блокировка При оптимистичной блокировке на базе данных реальной блокировки не происходит. Вместо этого используется следующий подход - если во время выполнения транзакции она изменяет данные, которые были изменены после её начала, то транзакция прерывается с исключением. Использование оптимистичных блокировок позволяет избежать взаимных блокировок (dead-lock). Для реализации оптимистичной блокировки часто используется версионирование данных - в таблицу добавляется колонка, которая хранит текущую версию.</description>
    </item>
    
  </channel>
</rss>
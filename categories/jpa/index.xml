<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jpa on Software Development and related activities</title>
    <link>https://uthark.github.io/categories/jpa/</link>
    <description>Recent content in Jpa on Software Development and related activities</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Apr 2012 15:03:00 +0000</lastBuildDate>
    
	<atom:link href="https://uthark.github.io/categories/jpa/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Собственная реализация методов в Spring Data JPA</title>
      <link>https://uthark.github.io/2012/04/28/spring-data-jpa_28/</link>
      <pubDate>Sat, 28 Apr 2012 15:03:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/28/spring-data-jpa_28/</guid>
      <description>Очевидно, что мы не всегда можем воспользоваться автоматической генерацией кода, предоставляемой Spring Data JPA. Например, у нас слишком сложный запрос, или нам необходимо вызвать процедуру в базе данных, либо у нас сложная бизнес-логика.
Рассмотрим следующий пример - например, нам нужна функциональность уникального счётчика, который мы решили реализовать с помощью последовательности (sequence).
Сначала определим интерфейс, в котором опишем все методы, которые мы будем реализовывать самостоятельно. В нашем случае, это будет только один метод:</description>
    </item>
    
    <item>
      <title>Ищем с помощью Spring Data JPA</title>
      <link>https://uthark.github.io/2012/04/24/spring-data-jpa/</link>
      <pubDate>Tue, 24 Apr 2012 14:04:00 +0000</pubDate>
      
      <guid>https://uthark.github.io/2012/04/24/spring-data-jpa/</guid>
      <description>Рассмотрим подробнее одну из наиболее полезных вещей в Spring Data JPA - генерация JPQL-запросов на основе имени метода.
Spring Data JPA умеет автоматически генерировать запросы используя для подсказки название метода.
Например, метод User.findByLoginAndPassword сгенерирует примерно следующий код:
FROM User u where u.login = :login and password = :password Вообще Spring Data JPA пытается быть умным, поэтому реализация findBy{&amp;hellip;} методов ищется следующим образом:
 Сначала смотрится аннотация @Query на объявлении метода, если она есть, то используется.</description>
    </item>
    
  </channel>
</rss>